\section{Reasons to choose Cloud Based Services}
This section is going to compare cloud based services with self hosted ones. The focus lies hereby on Firebase, cloud based services, and Node Js with Express as the self hosted server. 

\subsection{Node Js}
Node Js, or Node, opens up Javascript for server side development. Its engine based on the V8 engine, which is the runtime of Google. In contrast to the V8 engine, which supports Javascript in the browser, Node is oriented towards long running sessions \cite{tilkov2010node}. Node on the contrary to most other development languages does not need multithreading for concurrent execution, because it is running a so called asynchronous event loop. Most web servers other than Node based ones, are making great use of multiprocessing. This allows for true parallelism, each thread core executing a different thread. This increases performance by a lot \cite{tilkov2010node}. On single core processors on the other hand, the processor must make context switches. For example while writing to a TCP socket, the processor is going to switch to another thread to keep himself busy \cite{tilkov2010node}. When working with multithreaded applications, there are a lot of things which can go wrong. There are deadlocks, resource sharing, race conditions, all in all it is a rather complex task \cite{tilkov2010node}. 

An event based programming system on the other hand works based on events. An application registers interest in a specific event and when this event happens the operating system notifies the application, allowing the application to execute the desired code \cite{tilkov2010node}. An important part of an event based system is asynchronous I/O \cite{chaniotis2015node}. Using the same example from above, the application is writing to a socket and the underlying socket buffer is filled. If the I/O is synchronous, the whole application would be frozen and not able to respond to any events. On the other hand if the I/O is asynchronous the applications registers the buffer is full and can not be filled further, this allows the application to execute other tasks while waiting for the event to fill the buffer further \cite{tilkov2010node}. Like multithreaded programs implementing an asynchronous event-driven application has its downsides too. For example not every communication can be tied into an event system \cite{tilkov2010node}.  

In Node all I/O operations are asynchronous \cite{chaniotis2015node}. Excluding a few operations like renaming a file. This means the control is immediately returned to the caller and therefore not blocking the application \cite{tilkov2010node}. Therefore the flow of the application is determined by the events in which the application is interested in, each event invokes a handler. This handlers never blocks the application on I/O or network requests \cite{doglio2015pro}.

A web server implemented in Node is capable of serving many users all while running single threaded. This is possible because the main loop only registers to the desired events and never does I/O or business logic processing \cite{tilkov2010node}. The I/O or network request events trigger the actual processing where only a few bytes are written, and as soon as an I/O or network request has to be made, the app asynchronously executes it and immediately returns the control. Therefore, even though a Node application runs single threaded the event-loop is never blocked and is capable of serving many users, all while waiting for I/O \cite{tilkov2010node}.